# Knowledge Base Search (RAG) - Flask App

This repository is a small Knowledge Base Search web application built with Flask and a Retrieval-Augmented Generation (RAG) pipeline using vector search (FAISS) and optional Google Gemini (Gemini API) for answer generation.

The app lets you upload PDF and TXT documents, processes them into vector embeddings, and provides a web UI to ask questions over the uploaded documents. If a Google Gemini API key is provided, the app will use Gemini to generate natural language answers from the retrieved document context.

Contents
- `app.py` - Flask application and the RAG pipeline (document processing, upload, search endpoints).
- `config.py` - Application configuration and folders creation.
- `requirements.txt` - Python package dependencies used by the project.
- `templates/` - Jinja2 HTML templates for the UI (`index.html`, `upload.html`, `base.html`).
- `static/` - Static assets (CSS and JS).
- `uploads/` - Temporary upload folder (created at runtime).
- `documents/` - Folder where processed documents are stored (created at runtime).
- `vector_store/` - FAISS index files are saved here after processing.

Quick summary
- Upload your PDFs/TXT files via the Upload page or POST to `/api/upload`.
- Run processing (automatic after upload or manually via `/api/process`) to build the FAISS vector index.
- Ask queries on the Search page — the app will return the top relevant document excerpts. If `GEMINI_API_KEY` is configured, the app will also attempt to generate a succinct answer using Gemini.

Prerequisites
- Python 3.11+ recommended.
- Windows (PowerShell) — instructions below are written for PowerShell.
- A virtual environment is strongly recommended.
- Optional: Google Gemini API key if you want natural language answers generated by Gemini.

Install and setup (PowerShell)
1. Open PowerShell and change directory to the project root:

```powershell
cd 'C:\Users\LENOVO\Downloads\knowledge-base-search'
```

2. (Optional but recommended) Create and activate a virtual environment:

```powershell
python -m venv .venv
.\.venv\Scripts\Activate.ps1
```

3. Upgrade pip and install dependencies:

```powershell
python -m pip install --upgrade pip
pip install -r requirements.txt
```

Notes about dependencies
- The project uses FAISS and sentence-transformers. On Windows, installing `faiss-cpu` and some heavy ML packages can be tricky. The `requirements.txt` includes `faiss-cpu` and `sentence-transformers` which may pull large binary wheels. If you run into issues, see Troubleshooting below.

Configuration
- Environment variables are read via `python-dotenv`. You can create a `.env` file in the project root to set values.

Common variables
- `GEMINI_API_KEY` — (optional) your Google Gemini API key. If unset or the placeholder value is used, the app will still run but will return raw document excerpts instead of Gemini-generated answers.
- `SECRET_KEY` — Flask secret key (defaults to a dev key if not set).

Example `.env` file

```
GEMINI_API_KEY=your_real_gemini_api_key_here
SECRET_KEY=replace-this-with-a-secret
```

First run and processing
1. Ensure folders are present (the app creates them automatically via `config.py`, but confirm): `uploads/`, `documents/`, `vector_store/`.

2. Start the app (development mode):

```powershell
# If using virtual environment, make sure it's activated
python app.py
```

3. Open a browser and go to:
- Search page: http://127.0.0.1:5000/
- Upload page: http://127.0.0.1:5000/upload

Uploading documents
- Use the Upload page UI to select and upload `.pdf` and `.txt` files.
- The backend saves uploaded files into the `documents/` folder and automatically triggers `process_documents()` which builds the FAISS index and saves it under `vector_store/faiss_index`.

API endpoints
- `GET /` - Search UI.
- `GET /upload` - Upload UI.
- `POST /api/upload` - Upload a single file (form field name `file`).
- `POST /api/process` - Manually trigger reprocessing of all files in `documents/`.
- `POST /api/search` - Submit a JSON body `{ "query": "your question" }`. Returns JSON with `answer`, `sources`, and `query`.
- `GET /api/documents` - List uploaded documents and their sizes.
- `GET /api/status` - Returns status: documents count, whether the vector store is loaded, and whether Gemini is configured.

How the pipeline works (high level)
- The app loads all `.pdf` and `.txt` files from `documents/`.
- Each document is converted into a `langchain.schema.Document` object.
- Documents are split into chunks using `RecursiveCharacterTextSplitter` (configurable in `config.py`).
- Embeddings are created using `sentence-transformers/all-MiniLM-L6-v2` via `HuggingFaceEmbeddings` (fallbacks in `app.py` exist if import fails).
- FAISS vector index is created from the document chunks and saved locally.
- A search performs a similarity search and either returns raw excerpts or asks Google Gemini to generate a final answer from the retrieved context.

Troubleshooting
- If installation of `faiss-cpu` fails on Windows:
  - Try installing a pre-built wheel compatible with your Python version and OS. Search for `faiss-cpu` wheels or consider using WSL (Windows Subsystem for Linux) where installing these packages is usually easier.
  - Alternatively, you can substitute FAISS with another vector store supported by LangChain (for example, Chroma) by updating `app.py`.

- If embeddings import fails (missing `langchain_community.embeddings`):
  - The app falls back to `FakeEmbeddings` or a simple hard-coded embedding. This will let the app run but search quality will be poor.

- If Gemini API calls fail:
  - Verify `GEMINI_API_KEY` in `.env` and that the key has the correct permissions.
  - Check the printed logs when the app starts — the app prints whether Gemini was successfully configured.

Security notes
- This project is intended for local or trusted network use only. It does not implement authentication or file size/type scanning beyond a simple whitelist. Do not deploy to production without adding authentication, file validation, rate limiting, and other security best practices.

Development tips and next steps
- Add authentication for the upload and search APIs.
- Add asynchronous processing / background worker for document processing (Celery, RQ or a background thread) to avoid blocking uploads.
- Add unit tests for key functions (text extraction, chunking, vector store creation, and API endpoints).
- Consider swapping FAISS for a managed vector DB if you plan to scale.


